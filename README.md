## 图像拼接

### 功能

实现了对两张或多张图像的拼接算法，不存在由于单应变换造成的缺失问题。高分辨率用的是ORB算法，低分辨率图像用的是SIFT算法，想换成相应的算法可在detectAndDescribe函数中进行修改。测试数据方面（存放在sourcedata里面），针对实际分辨率为640\*512的红外图像及可见光窗口图像，各准备了5组测试数据进行测试；实际分辨率为2048\*1536和4096\*3072的可见光窗口图像分别准备了4组和3组数据进行测试。

### 参数及使用

| 参数          | 说明                          |
|:-----------:|:---------------------------:|
| --list      | 待拼接的图片路径，至少有两张图片            |
| --transpath | 中间结果的保存路径，默认是tansformed.png |
| --savepath  | 最终结果保存路径，默认是processed.png   |

示例

```powershell
.\main.exe  --list .\image1.png .\image2.png --transpath tmp.png --savepath result.png
```

这里是用pyinstaller生成了exe可执行文件，如果用源码执行的话参数同上。

### 存在的问题

为了解决单应变换造成的缺失问题，我先将第一张图进行了单应变换并且进行了平移。然后将变换后的图再去和第二张图进行一次拼接。由于用了两次特征点寻找和匹配的算法，所以在高分辨率图像拼接的时候速度会慢，并且多张图像拼接的时候速度也会变慢。速度和CPU的性能也有很大关系，CPU越好速度也会越快。低分辨率图像拼接速度还行。

两张图像拼接基本没有问题，就是没有进行图像融合，边界部分有一条白线。多张图像拼接除了速度问题外，还有一个拼接顺序问题没完全解决，由于我这个是逐步拼接的，多张图片拼接的时候，如果有两张图片没有交集，无法进行拼接，需要找出一个顺序来。我写了一个判断过程，但没完全写，因为多张高分辨率图像特征点太多，用我这个代码会卡死。所以高分辨率多张拼接就没判断顺序，低分辨率的图像可以是可以，但速度也会降低，而且测试图像基本都是按顺序有交集的，顺序基本也没变，所以基本没啥用。

### 代码重构

对代码进行了重构，删减了一些东西，同时把注释也加了上去，代码放在refactor中，具体参数见代码。还未解决的问题也写了一个文档放在其中。
